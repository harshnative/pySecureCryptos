# rsa Wrapper

Asymmetric encryption algo using public and private keys. Best for encryption for network systems.

This does not have a verifier version as checksum is implode in this already as this encryption algo is mainly used in network system where the data corruption rate is very high. So a non verifier version will be out of point.




<br>
<br>
<br>















<!-- 
 _                                      _    
(_)  _ __ ___    _ __     ___    _ __  | |_  
| | | '_ ` _ \  | '_ \   / _ \  | '__| | __| 
| | | | | | | | | |_) | | (_) | | |    | |_  
|_| |_| |_| |_| | .__/   \___/  |_|     \__| 
                |_|                           -->


# Importing - 

``` python
from pySecureCryptos import rsaWrapper as RW 
```




<br>
<br>
<br>
<br>
<br>












<!-- 
                    _     _                   _  
 _ __ ___     ___  | |_  | |__     ___     __| | 
| '_ ` _ \   / _ \ | __| | '_ \   / _ \   / _` | 
| | | | | | |  __/ | |_  | | | | | (_) | | (_| | 
|_| |_| |_|  \___|  \__| |_| |_|  \___/   \__,_| 
                                                  -->


# Methods - 

1. Generate key pair
2. Encrypt and Decrypt strings
3. Encrypt and Decrypt bytes
4. Encrypt and Decrypt large strings
5. Encrypt and Decrypt large bytes


<br>
<br>
<br>
<br>
<br>
<br>
















 <!-- _  
/ | 
| | 
| | 
|_| 
     -->

# 1. Generate Key pairs

<br>

## Setup

You need to make a object from the class KeyGenerator

```python
keyGen_obj = RW.KeyGenerator(size = 4096)
```


Arguments - 

* size -> key size , more the better , must a multiple of 256.

Note -> generating a key is a compute expensive process

<br>
<br>

### 1.1 get private - in bytes format

``` python
keyGen_obj.get_privateKey_bytes()
```

* returns private key in bytes format. this is meant to be kept secure on the server itself. it is used for decryption.

<br>
<br>

### 1.2 get private - in bytes string

``` python
keyGen_obj.get_privateKey_string()
```

* returns private key in string format. this is meant to be kept secure on the server itself. it is used for decryption.


<br>
<br>

### 1.3 get public - in bytes format

``` python
keyGen_obj.get_publicKey_bytes()
```

* returns public key in bytes format. Share this with client , so that they can encrypt your data with this.

<br>
<br>

### 1.4 get public - in bytes string

``` python
keyGen_obj.get_publicKey_string()
```

* returns public key in string format. Share this with client , so that they can encrypt your data with this.




<br>
<br>
<br>
<br>
<br>


















<!-- 
 ____   
|___ \  
  __) | 
 / __/  
|_____| 
         -->


# 2. Bytes Encryptor

<br>

## Setup

You need to make a object from the class Encryptor

```python
encObj = RW.Encryptor(publicKey , privateKey , keySize = 4096)
```


Arguments - 

* publicKey -> public key generated by KeyGenerator(). can be bytes or string type.
* privateKey -> private key generated by KeyGenerator(). can be bytes or string type.
* keySize -> keySize set in KeyGenerator(). Wrong key size may lead to errors in encryption saying plain text is too long.


<br>
<br>

### 2.1 encrypt byte

``` python
encObj.encrypt_byte(byte)
```

* byte -> byte you want to encrypt
* returns encrypted byte

<br>
<br>

### 2.2 decrypt byte

``` python
encObj.decrypt_byte(enc_byte)
```

* enc_byte -> encrypted byte from encObj.encrypt_byte()
* returns decrypted byte

<br>
<br>

Example - 

```python

    print("generating key")
    keyGenObj = KeyGenerator()

    privateKey_bytes = keyGenObj.get_privateKey_bytes()
    privateKey_string = keyGenObj.get_privateKey_string()

    publicKey_bytes = keyGenObj.get_publicKey_bytes()
    publicKey_string = keyGenObj.get_publicKey_string()

    print("making obj")
    encObj = Encryptor(publicKey_bytes , privateKey_bytes)

    myByte = b"hello world"

    print(f"encrypting byte of len = {len(myByte)}")


    encryptedByte = encObj.encrypt_byte(myByte)

    print(f"encryptedByte = {encryptedByte} len = {len(encryptedByte)}")

    
    decryptedByte = encObj.decrypt_byte(encryptedByte)

    print(f"decryptedByte = {decryptedByte} len = {len(decryptedByte)}")

    if(decryptedByte != myByte):
        print("\nerror")
    else:
        print("\nok")


    # test with string keys
    print("making obj")
    encObj = Encryptor(publicKey_string , privateKey_string)
    
    decryptedByte = encObj.decrypt_byte(encryptedByte)

    print(f"decryptedByte = {decryptedByte} len = {len(decryptedByte)}")

    if(decryptedByte != myByte):
        print("\nerror")
    else:
        print("\nok")

    print("done")
```


Output - 

```shell
generating key
making obj
encrypting byte of len = 11
encryptedByte = b'\x19\x15\xba\x8eX1H\x8c\x05\xbb\x89\xa9\xfd8\xfa\x1d\x16\x98\xe9&=N\xca\xa5\xac\x19\xdcj\xa7\x82\xdd\x83\x86r\x82`Z\xe0k\xbb\x98\x81\xc0\xc2%\xa9\xa3\xf8\xb6\xe6\xd5}\xed>f\x82t\x92\xf2\xbc\xfb)m\xa1f\xb5\x83\xb2f5\xf7\xae\x95QM\xe7\x9e\x97\xbf\t\xbc=\xd1\xc9\x01\xcds\x1c\x12\xc6b\x9c\x19O\xba\xe9\x0f\xdb\x96n$\xd6\xcc\xfa\xa6v\x7f\xbc\xf1\xe8\xb2\xa4\xbaX=-\xc3\x81Q\xc7\xdc\xba_M\xd7\x87HA%f\xa8\x05\x05_?\xdf#(Dv\x03\xce\x14_?\xad\xa5\xc3\x00\x8f\xc1\x80\xe4\x91\x18I-\t\xb1NV\xcd\xc8\xbd\xe0\xdf\xe5\x10\x1fF\x94\x85>\xde=-Ld\x85l&\xf1\xc0(Z\x7f*\x19\xb6\x8a\x04\x00\xa9\xea\xde"A?\x9f\xbf\xdc\x9d\xe5\xe7\xd6\xd9 \x06\x81a\x03i\xa6Zc\xa8\x15\xc2 \xaf\xdb\x91v\xc8\xbe7\xab\x0b\x1d\xa5\x05\xd3\x87<9\x83*\ri\xf2}="\xe1\xc7\xae\x95w\tYDB\xd7\x1b\xaa\x89\xa2\x1c\x11\x91/\x17\x0c\x0c1qz\x82\x9ez\n\xd1Q\x8a+1?\xa8\x86\x8d\xb7\xe6\x17-\x18\xb3Z\x8bJ\xfc?\xedF\x89\xf0\xe0i\x94\x92\xb8\x7fZn\xc9\xf7\xb7O\x81\xef\xde\xc9\x15\x16M2\x83\xea\x84\xc98\x1c\xfb\xcez\xfb\xed\xc6<\xc1\x956\xb1\x957=\xc4\x0fz\xa5\'\x0eGs5\xd9l\xa9_\xf9:\xec\xfa?\xc8H\xcd\xb8rv\x9e\xc1\x9a:\xf6/\xa9\x86m\xf6\x167\x18e\x12\x16\x9cx\xd7\xea\xf37\xf2\xf6\xbc\xe6\xfd\xd0\x02\xc0\xc8\xd2\xfd!\x80\x04\x18\xb5\x7f\x14\xd2m\xb1h\xa4<\xcf\x1b8>W\x07\x18\xc3\x00\x19+\x83{0\xd3kN\xe8\xdd\x89\xf3\xef\x04qd\xf6*\xcfK|\xd7\x84\x99\xe6\x7fv2\x9c\x0f\xd9\xcb\x1e\x1b\x8c&\xf50~\x950\xd8\xe8c\xd8\xd5\xcd<\x83I_\xda\x06&5\x06\x02\xa3\x87\x1eB\x8a\xb2\x8f&wM\x80\xf3\x0fJ\x89Gy\xda\xf1>"\xd7\xe6\xb1\xc0^{Y\xaa0tH\xbeN\t\x9f\x87\x82.\xbe\xf3:checksum:;|@]\xe3\xb0m\x93{,\x15i\xea\xc0!KO\xf6\x9b\xf3BDO\xb02\x8b\xe5\x95\x1f\xda\xc2p\n\x9bB!XCg\xe1\x83\x88\x88\x0e\x0f\xa1g\x97\xd3\x03\x81x\xbbS\xf8\x9a\xf6\xc5\xc9\x02\x84\xf0\x18x\xa6\xe71\x02%|\xa0\xeb\xce\x1bK[\x88\xb7DI\xdf\xf0&\xb00QeW\x1e\x19\xb5\x07\x99\x99\xe1\xf5\x9d6\xaeV_\x8a+)o\xdau\xb7\x9fa\xa4C\xd6W\xe2n\xbap\xfc\xd86E ]>\xef\x8c\xf74\xf2\x99\xe1\xe0\xdbc;\'R\\<\xd1\x88\x9a>\xa6\x88\x18\xb2$\xec{\x92\x80\xffE5\xad\xa5\xafMc\xb2\xcbX\xf0F~3\xfd\xea\xecd\x96# 8`\x97\xf3\x81&\xa6/\x98M\xae34\xf3\xf2\xdd\x89\r\x15\xc2\xa0\xc3\xd7G\xbf\xbf\xb9\xca\xf49\xb1\xd6\xbc\xf7O\x06\xacv2\xe4g\x08\xfe\xfb\xe9G\xef\x122\xc8\xffc2\xa0*7K\xfb\xb0\x11\xa0\x01\x00\xa0\x9e\xdf\xf3\xfb\xf0{b\x7f\xbb\x1e:\x1a-\xfa\xc9l\x19t\xdc\x9dl&\xf5|.\x93\x00\xc1_\xbek\x02\x9bw\x144_\x0f\xba2<\x95\xeb\x0ei\x03\x8f\x95UO`\xcb-f\xc2\x88\x1e\xa5;\xd8\x02\xe7\x13\xc3\xa1 \xcdh\xc2\x00\\\x9a:\xa5\x95h#\xf3\x06\xb3(m\xe3Bb\x17\xd7\xd7\x92\xe6\xef}<\xfc\x8e\xd3]\xfd~\x15\xcfJg\xef\x90\xb0\xcc\xd1\xda\xfa|\x92\x10kq\x8d\xc3\x89v\x1f\x99<\xdd\xee\x99\xe7\xe3o\xb4\xe0\xa5\xed\x0c\xaao\x11\x15\xed.\x0b\xed\x92@\xd8G\x170BK\xc5\nx\x89(\x14Z\x13\xbb\x05\xeb{S\xf4>G\xee\xc3/q\xbe\xa1\x8f\xf4\xb4\xa7\xaa\x1a\xfb%\xef]\xd3`\xb3\xc4\xb0\xde\xcf\xe1EI\xd8*\x86L\xde*\xd3\xd5*U\xce\x89\xe6\x85\'\xaa9\xd6\xa9A\xdc\xf7\x10a\x00\xf2\xbcu\xac/\xde\xcb\x00\x16\xee?\'[\xa8\x9d\x8b!\xa2B\x9ce\xaa<K\x1a\xad\xc4\xd5u2\x1d7\xd2\xf2NQ\xed=\xa3w\xa1\xd6\xd7\xbb5\x07\x87\xd1o\xec\xe7rR\x9c\n\xc1O' len = 1034
decryptedByte = b'hello world' len = 11

ok
making obj
decryptedByte = b'hello world' len = 11

ok
done

```


<br>
<br>
<br>

NOTE -> Both the above method also have a generator version which are important in tracking the progress of encryption and decryption of large data.















<br>
<br>
<br>

### 2.3 generator version - encrypt byte

``` python
encObj.encrypt_byte_yield(byte)
```

* byte -> byte you want to encrypt
* returns encrypted byte

<br>
<br>


### 2.4 generator version - decrypt byte

``` python
encObj.decrypt_byte_yield(enc_byte)
```

* enc_byte -> encrypted byte
* returns decrypted byte

<br>
<br>


Example - 

```python

    print("generating key")
    keyGenObj = KeyGenerator()

    privateKey_bytes = keyGenObj.get_privateKey_bytes()
    privateKey_string = keyGenObj.get_privateKey_string()

    publicKey_bytes = keyGenObj.get_publicKey_bytes()
    publicKey_string = keyGenObj.get_publicKey_string()

    print("making obj")
    encObj = Encryptor(publicKey_bytes , privateKey_bytes)

    myByte = b"hello world" * 12345

    print(f"encrypting byte of len = {len(myByte)}")


    genObj = encObj.encrypt_byte_yield(myByte)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            encryptedByte = ex.value
            break
    print()

    print(f"encryptedByte len = {len(encryptedByte)}")

    
    genObj = encObj.decrypt_byte_yield(encryptedByte)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            decryptedByte = ex.value
            break
    print()

    print(f"decryptedByte len = {len(decryptedByte)}")

    if(decryptedByte != myByte):
        print("\nerror")
    else:
        print("\nok")


    # test with string keys
    print("making obj")
    encObj = Encryptor(publicKey_string , privateKey_string)
    
    genObj = encObj.decrypt_byte_yield(encryptedByte)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            decryptedByte = ex.value
            break
    print()

    print(f"decryptedByte len = {len(decryptedByte)}")

    if(decryptedByte != myByte):
        print("\nerror")
    else:
        print("\nok")

    print("done")
```

Output - 

```shell
generating key
making obj
encrypting byte of len = 135795

Progress: |██████████████████████████████████████████████████| 100.0% Complete

encryptedByte len = 206800

Progress: |██████████████████████████████████████████████████| 100.0% Complete

decryptedByte len = 135795

ok
making obj

Progress: |██████████████████████████████████████████████████| 100.0% Complete

decryptedByte len = 135795

ok
done

```



<br>
<br>
<br>
<br>
<br>














<!-- 
 _____  
|___ /  
  |_ \  
 ___) | 
|____/  
         -->


# 3. String Encryptor

<br>

## Setup

You need to make a object from the class Encryptor

```python
encObj = RW.Encryptor(publicKey , privateKey , keySize = 4096)
```


Arguments - 

* publicKey -> public key generated by KeyGenerator(). can be bytes or string type.
* privateKey -> private key generated by KeyGenerator(). can be bytes or string type.
* keySize -> keySize set in KeyGenerator(). Wrong key size may lead to errors in encryption saying plain text is too long.


<br>
<br>

### 3.1 encrypt string

``` python
encObj.encrypt_string(string)
```

* string -> string you want to encrypt
* returns encrypted string

<br>
<br>

### 3.2 decrypt string

``` python
encObj.decrypt_string(enc_string)
```

* enc_string -> encrypted string from encObj.encrypt_string()
* returns decrypted string

<br>
<br>

Example - 

```python

    print("generating key")
    keyGenObj = KeyGenerator()

    privateKey_bytes = keyGenObj.get_privateKey_bytes()
    privateKey_string = keyGenObj.get_privateKey_string()

    publicKey_bytes = keyGenObj.get_publicKey_bytes()
    publicKey_string = keyGenObj.get_publicKey_string()

    print("making obj")
    encObj = Encryptor(publicKey_bytes , privateKey_bytes)

    myString = "hello world"

    print(f"encrypting string of len = {len(myString)}")


    encryptedString = encObj.encrypt_string(myString)

    print(f"encryptedString = {encryptedString} len = {len(encryptedString)}")

    
    decryptedString = encObj.decrypt_string(encryptedString)

    print(f"decryptedString = {decryptedString} len = {len(decryptedString)}")

    if(decryptedString != myString):
        print("\nerror")
    else:
        print("\nok")


    
    # testing with string key 
    print("making obj")

    encObj = Encryptor(publicKey_string , privateKey_string)
    decryptedString = encObj.decrypt_string(encryptedString)

    print(f"decryptedString = {decryptedString} len = {len(decryptedString)}")

    if(decryptedString != myString):
        print("\nerror")
    else:
        print("\nok")

    print("done")
```


Output - 

```shell
generating key
making obj
encrypting string of len = 11
encryptedString = 56c18edc1c60441f871488b4aaf03f67e1eddab5d7096c099ac67989fc287c404221e4c5c6949d3620009818be829b47114ad064211963901c69875d81203bb141e6d198e3c7fd41ee9b337bb4721e6f0c956a72fb2e45cf645c999c89c314e474fea4dcc9ccdb52c7e8bf12592775319b6d9204575b4fe99f54faa52fd55d2271506b30cae24b09996933c72d1a6813a4780f846c2c2fdf5cd723b6837d16cec87eb73521fd955b3241f7e9566d474c30b74de61da19dc702200cc14180658f6dd723ddf90af8a27e20e3df127ad217bae4c19a1885d80883aa07dc8ed4ff6df759fcd3f432c37e1e86e4dd413b50bee83e7b3c1ac313d0fcc2dc8a7e3786375b3321fe40d869a7b1fe2a6fc0b983409f8eef605584be586ba8f81c74277167969db9078aea24c679d8d677c50e2d41c8069b81d3ea8b9c0872ab4140fbc02253e81eb49943f241ef3c576ad0f3b4337d5bc7ca4f8efbe1770b410910bfe88e902ad9288a7abab6936b53dc206223bdae72c081c042ccaaf6a5477a7e11cac0b1b40dd51896d2ed13ca896149e7dc53028525dbd960c203e17d675da90d5db55a026104412623248fc5592301a989f8e0c422b16215065a1001fd94960238a0322dc1cae6fba5b9ffa43ea5da3bfbba4d430cda2c47ebac2ac7092b13c9ae03a24893121860af8af3ebf60ce6cd8111ea0482c7f79a603b37ee6cce3334258b:checksum:1c89f15f388e1c91b5cd9d5cd6ce6ee8253c1f674f9f13630da3677410ad71323588aa7e4dd96f108f91eaeecddff312e70377cee5f3adc07b084ccf303b9661092ee0b16554b2034729ddf9d81ebd63c420d07c7452354223497492a95adb1f89a32b2324972d4d29b4d61fa1932ec1a4d8de92680369508b26a03fba56ff2624e96e3ee0c1cbb45c53c246705bd75be4ded9d22730f09e8767ecc63f834a630aa1bd4998a5dd70738d9ff5df41068048efc234fc882da08b4ab886052767a5f980838f435c7ded0abf53d1858b02ec658a483db0370093284b75a2a566a6ece3f902e54a890764b2b0c210129ddbb3137d82b3e3cf6b62f85ce52bdb36c61fd5e479046d647df1c6134899cfc2558d9a9cd8a7e3add1f2cdb8349d5f20a027803719b84d6cd502e8a4a76b916f6c48fbb687d77e526d1e9422fdf5d6c524c30ab5ae57fbba3cf7f00d4516149ee136d777982daee825eab78cbf9e7e71ecf006ed5936daf3d4ea749de9919a68032add20a15b78f120fcc582a1f39a755208eb4a7801e283a96a6a12fd713d9ccc06e42eb5f9cdb4464bdb3caeefc58938083adb62deafbc7b66950cf2675357cdcc1984de33cc2413b795e34e0c6fe00cc978322d552762d691dc6690628f67dca616c93dba2ef55ff48f08d609f859657400aa0539e153a67874b3d268059280c940119c6901a3cf8ab908b86c6e1fed36 len = 2058
decryptedString = hello world len = 11

ok
making obj
decryptedString = hello world len = 11

ok
done

```


<br>
<br>
<br>

NOTE -> Both the above method also have a generator version which are important in tracking the progress of encryption and decryption of large data.



<br>
<br>
<br>






























### 3.3 generator version - encrypt string

``` python
encObj.encrypt_string_yield(string)
```

* string -> string you want to encrypt
* returns encrypted string

<br>
<br>


### 3.4 generator version - decrypt string

``` python
encObj.decrypt_string_yield(enc_string)
```

* enc_string -> encrypted string
* returns decrypted string

<br>
<br>


Example - 

```python

    print("generating key")
    keyGenObj = KeyGenerator()

    privateKey_bytes = keyGenObj.get_privateKey_bytes()
    privateKey_string = keyGenObj.get_privateKey_string()

    publicKey_bytes = keyGenObj.get_publicKey_bytes()
    publicKey_string = keyGenObj.get_publicKey_string()

    print("making obj")
    encObj = Encryptor(publicKey_bytes , privateKey_bytes)

    myString = "hello world" * 12345

    print(f"encrypting string of len = {len(myString)}")


    genObj = encObj.encrypt_string_yield(myString)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            encryptedString = ex.value
            break
    print()

    print(f"encryptedString len = {len(encryptedString)}")

    
    genObj = encObj.decrypt_string_yield(encryptedString)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            decryptedString = ex.value
            break
    print()

    print(f"decryptedString len = {len(decryptedString)}")

    if(decryptedString != myString):
        print("\nerror")
    else:
        print("\nok")


    
    # testing with string key 
    print("making obj")

    encObj = Encryptor(publicKey_string , privateKey_string)
    genObj = encObj.decrypt_string_yield(encryptedString)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            decryptedString = ex.value
            break
    print()

    print(f"decryptedString len = {len(decryptedString)}")

    if(decryptedString != myString):
        print("\nerror")
    else:
        print("\nok")

    print("done")
    
```

Output - 

```shell
generating key
making obj
encrypting string of len = 135795

Progress: |██████████████████████████████████████████████████| 100.0% Complete

encryptedString len = 411600

Progress: |██████████████████████████████████████████████████| 100.0% Complete

decryptedString len = 135795

ok
making obj

Progress: |██████████████████████████████████████████████████| 100.0% Complete

decryptedString len = 135795

ok
done

```



<br>
<br>
<br>
<br>
<br>
<br>

















<!-- 
 _  _    
| || |   
| || |_  
|__   _| 
   |_|   
         
 -->

# 4. Large String Encryptor

Uses multi processing technique to encrypt large object much faster.

Encrypts the main object using fernet wrapper with 512 bits key. then adds this key encrypted using rsa.

<br>

## Setup

You need to make a object from the class Encryptor

```python
encObj = RW.Encryptor(publicKey , privateKey , keySize = 4096)
```


Arguments - 

* publicKey -> public key generated by KeyGenerator(). can be bytes or string type.
* privateKey -> private key generated by KeyGenerator(). can be bytes or string type.
* keySize -> keySize set in KeyGenerator(). Wrong key size may lead to errors in encryption saying plain text is too long.


<br>
<br>

### 4.1 encrypt string

``` python
encObj.encrypt_lstring_yield(large_string , chunkSize = 4)
```

* large_string -> large_string you want to encrypt
* chunkSize in MB -> depends on your processing power of CPU , more power , larger can be the chunk size
* returns encrypted string

<br>
<br>

### 4.2 decrypt string

``` python
encObj.decrypt_lstring_yield(large_string)
```

* large_string -> encrypted string from encObj.encrypt_lstring_yield()
* returns decrypted string

<br>
<br>

Example - 

```python

    print("generating key")
    keyGenObj = KeyGenerator()

    privateKey_bytes = keyGenObj.get_privateKey_bytes()
    privateKey_string = keyGenObj.get_privateKey_string()

    publicKey_bytes = keyGenObj.get_publicKey_bytes()
    publicKey_string = keyGenObj.get_publicKey_string()

    print("making obj")
    encObj = Encryptor(publicKey_bytes , privateKey_bytes)

    # 48 mb of data
    myString = "h" * 1024 * 1024 * 48

    print(f"encrypting string of len = {len(myString)}")


    genObj = encObj.encrypt_lstring_yield(myString)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            encryptedString = ex.value
            break
    print()

    print(f"encryptedString len = {len(encryptedString)}")

    
    genObj = encObj.decrypt_lstring_yield(encryptedString)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            decryptedString = ex.value
            break
    print()

    print(f"decryptedString len = {len(decryptedString)}")

    if(decryptedString != myString):
        print("\nerror")
    else:
        print("\nok")


    
    # testing with string key 
    print("making obj")

    encObj = Encryptor(publicKey_string , privateKey_string)
    genObj = encObj.decrypt_lstring_yield(encryptedString)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            decryptedString = ex.value
            break
    print()

    print(f"decryptedString len = {len(decryptedString)}")

    if(decryptedString != myString):
        print("\nerror")
    else:
        print("\nok")

    print("done")
```


Output - 

```shell
generating key
making obj
encrypting string of len = 50331648

Progress: |██████████████████████████████████████████████████| 100.0% Complete

encryptedString len = 134231954

Progress: |██████████████████████████████████████████████████| 100.0% Complete

decryptedString len = 50331648

ok
making obj

Progress: |██████████████████████████████████████████████████| 100.0% Complete

decryptedString len = 50331648

ok
done

```





<br>
<br>
<br>
<br>
<br>



























<!-- 
 ____   
| ___|  
|___ \  
 ___) | 
|____/  
        
 -->

# 5. Large Bytes Encryptor

Uses multi processing technique to encrypt large object much faster.

Encrypts the main object using fernet wrapper with 512 bits key. then adds this key encrypted using rsa.

<br>

## Setup

You need to make a object from the class Encryptor

```python
encObj = RW.Encryptor(publicKey , privateKey , keySize = 4096)
```


Arguments - 

* publicKey -> public key generated by KeyGenerator(). can be bytes or string type.
* privateKey -> private key generated by KeyGenerator(). can be bytes or string type.
* keySize -> keySize set in KeyGenerator(). Wrong key size may lead to errors in encryption saying plain text is too long.


<br>
<br>

### 5.1 encrypt byte

``` python
encObj.encrypt_lbyte_yield(large_byte , chunkSize = 8)
```

* large_byte -> large_byte you want to encrypt
* chunkSize in MB -> depends on your processing power of CPU , more power , larger can be the chunk size
* returns encrypted byte

<br>
<br>

### 5.2 decrypt string

``` python
encObj.decrypt_lbyte_yield(large_byte)
```

* large_byte -> encrypted byte from encObj.encrypt_lbyte_yield()
* returns decrypted byte

<br>
<br>

Example - 

```python

    print("generating key")
    keyGenObj = KeyGenerator()

    privateKey_bytes = keyGenObj.get_privateKey_bytes()
    privateKey_string = keyGenObj.get_privateKey_string()

    publicKey_bytes = keyGenObj.get_publicKey_bytes()
    publicKey_string = keyGenObj.get_publicKey_string()

    print("making obj")
    encObj = Encryptor(publicKey_bytes , privateKey_bytes)

    # 64 Mb of data
    myByte = b"h" * 1024 * 1024 * 64

    print(f"encrypting byte of len = {len(myByte)}")


    genObj = encObj.encrypt_lbyte_yield(myByte)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            encryptedByte = ex.value
            break
    print()

    print(f"encryptedByte len = {len(encryptedByte)}")

    
    genObj = encObj.decrypt_lbyte_yield(encryptedByte)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            decryptedByte = ex.value
            break
    print()

    print(f"decryptedByte len = {len(decryptedByte)}")

    if(decryptedByte != myByte):
        print("\nerror")
    else:
        print("\nok")


    # test with string keys
    print("making obj")
    encObj = Encryptor(publicKey_string , privateKey_string)
    
    genObj = encObj.decrypt_lbyte_yield(encryptedByte)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            decryptedByte = ex.value
            break
    print()

    print(f"decryptedByte len = {len(decryptedByte)}")

    if(decryptedByte != myByte):
        print("\nerror")
    else:
        print("\nok")

    print("done")
    
```


Output - 

```shell
generating key
making obj
encrypting byte of len = 67108864

Progress: |██████████████████████████████████████████████████| 100.0% Complete

encryptedByte len = 89482480

Progress: |██████████████████████████████████████████████████| 100.0% Complete

decryptedByte len = 67108864

ok
making obj

Progress: |██████████████████████████████████████████████████| 100.0% Complete

decryptedByte len = 67108864

ok
done

```