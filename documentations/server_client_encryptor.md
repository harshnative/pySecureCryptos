# server client encryptor

* Combines properties of symmetric and asymmetric encryption algo.
* Combines RSA and AES encryption for faster encryption.
* Since it uses RSA , module as in built checking for message authentication i.e checks if the message is sent by the original sender.








<br>
<br>
<br>













<!-- 


 _                                      _    
(_)  _ __ ___    _ __     ___    _ __  | |_  
| | | '_ ` _ \  | '_ \   / _ \  | '__| | __| 
| | | | | | | | | |_) | | (_) | | |    | |_  
|_| |_| |_| |_| | .__/   \___/  |_|     \__| 
                |_|                           -->


# Importing - 

``` python
from pySecureCryptos import server_client_encryptor
```




<br>
<br>
<br>
<br>
<br>












<!-- 


                    _     _                   _  
 _ __ ___     ___  | |_  | |__     ___     __| | 
| '_ ` _ \   / _ \ | __| | '_ \   / _ \   / _` | 
| | | | | | |  __/ | |_  | | | | | (_) | | (_| | 
|_| |_| |_|  \___|  \__| |_| |_|  \___/   \__,_| 
                                                  -->


# Methods - 
1. Generate key pair
2. Encrypt and Decrypt bytes
3. Encrypt and Decrypt string


<br>
<br>
<br>
<br>
<br>
<br>











 <!-- _  
/ | 
| | 
| | 
|_| 
     -->

# 1. Generate Key pairs

<br>

## Setup

You need to make a object from the class KeyGenerator

```python
keyGen_obj = RW.KeyGenerator(size = 4096)
```


Arguments - 

* size -> key size , more the better , must a multiple of 256.

Note -> generating a key is a compute expensive process

<br>
<br>

### 1.1 get private - in bytes format

``` python
keyGen_obj.get_privateKey_bytes()
```

* returns private key in bytes format. this is meant to be kept secure on the server itself. it is used for decryption.

<br>
<br>

### 1.2 get private - in bytes string

``` python
keyGen_obj.get_privateKey_string()
```

* returns private key in string format. this is meant to be kept secure on the server itself. it is used for decryption.


<br>
<br>

### 1.3 get public - in bytes format

``` python
keyGen_obj.get_publicKey_bytes()
```

* returns public key in bytes format. Share this with client , so that they can encrypt your data with this.

<br>
<br>

### 1.4 get public - in bytes string

``` python
keyGen_obj.get_publicKey_string()
```

* returns public key in string format. Share this with client , so that they can encrypt your data with this.




<br>
<br>
<br>
<br>
<br>























<!-- 
 ____   
|___ \  
  __) | 
 / __/  
|_____| 
         -->


# 2. Bytes Encryptor

<br>

## Setup

You need to make a object from the class Encryptor

```python
encObj = server_client_encryptor.Encryptor(publicKey : Union[str , bytes] , privateKey : Union[str , bytes] , keySize : int = 4096 , chunkSize : int = 16)
```


Arguments - 

* publicKey -> public key generated by KeyGenerator(). can be bytes or string type.
* privateKey -> private key generated by KeyGenerator(). can be bytes or string type.
* keySize -> Default is set to 4096. should be same has the keySize in KeyGenerator(). Wrong key size may lead to errors in encryption saying plain text is too long etc.
* chunkSize - chunk size in MB , each chunks is encrypted individually and then joined together



<br>
<br>

### 2.1 encrypt byte

``` python
encObj.encrypt_byte(byte)
```

* byte -> byte you want to encrypt
* returns encrypted byte

<br>
<br>

### 2.2 decrypt byte

``` python
encObj.decrypt_byte(enc_byte)
```

* enc_byte -> encrypted byte from encObj.encrypt_byte()
* returns decrypted byte

<br>
<br>

Example - 

```python


    print("generating server key")

    keyObj_server = KeyGenerator()

    publicKey_server = keyObj_server.get_publicKey_bytes()
    privateKey_server = keyObj_server.get_privateKey_bytes()


    print("generating client key")

    keyObj_client = KeyGenerator()

    publicKey_client = keyObj_client.get_publicKey_bytes()
    privateKey_client = keyObj_client.get_privateKey_bytes()



    print("encrypting message server")
    encObj_server = Encryptor(publicKey_client , privateKey_server)

    myByte_server = b"hello world"


    encryptedByte_server = encObj_server.encrypt_byte(myByte_server)

    print(f"encryptedByte_server = {encryptedByte_server} , len = {len(encryptedByte_server)}")




    print("encrypting message client")
    encObj_client = Encryptor(publicKey_server , privateKey_client)

    myByte_client = b"hi there"


    encryptedByte_client = encObj_client.encrypt_byte(myByte_client)

    print(f"encryptedByte = {encryptedByte_client} , len = {len(encryptedByte_client)}")



    print("\n\n\n")

    print("client decrypting servers message")

    decryptedByte_client = encObj_client.decrypt_byte(encryptedByte_server)
    
    print(f"decryptedByte_client = {decryptedByte_client} , len = {len(decryptedByte_client)}")

    
    if(decryptedByte_client != myByte_server):
        print("\nerror")
    else:
        print("\nok")



    print("server decrypting clients message")

    decryptedByte_server = encObj_server.decrypt_byte(encryptedByte_client)
    
    print(f"decryptedByte_server = {decryptedByte_server} , len = {len(decryptedByte_server)}")

    
    if(decryptedByte_server != myByte_client):
        print("\nerror")
    else:
        print("\nok")

```


Output - 

```shell
generating server key
generating client key
encrypting message server
encryptedByte_server = b'\xbdD\t\x15ZE\xe3\x0b\x00\x10\xc7:-helper:-HB\x8c\x03C\x88u\x0fn\xa1p\xba\xde7\n\xc1:-helper:-\xc3\xb0u\xeb\xc5\xa0xw>\xe8\t\x15\xa7&\xf2B:-encKey-:\x10iK\x1b\xe2R\x92\xd6\xc5CWV\x08\xd1\xe6\xd34\rn`1UV\x92\xf3`\xcb\x14\xb2;\x9bt\xbd\x16(\t\x8d\x0b\xd3\x8cA\xa4\xf7\x82H\xe2\tR\x8d\xe1\x14\xc0-\xa8j_\xa8\xcf^>!\xd7_\xeb\xf4\xd3p\xa8\x1b\xdb\x84B\xb2\x8a\xdf\xf4[\xd0/\xbd<\xb2<\xf3\x99\x94\xee\x8e\xad/\xed:\xcbW;\x85~K03\xcd\xf1\x1fYY\xe9\xc3\xff#@O\xdcpLb\x0b\xcc\x98\x14\xd1E\xcb\xd0a\r\xe8Yi\x08\xab\xb7\xa6W;>Udp\xb2\xcc\xac\'\xcf\x01\xa0x\xfah\r\xf5\x8f\x99\xf7\x85Q\xe1\x0f\x9dO=\xb1\x16\xc6V&[\xe0L\rE%c(E\xf6\x06\xb3\xf9o\xd2\xb1U\xc0\xdd\x88\xde\x98\xe9\xde\xa4\xc0\xc9\x98\xd8\x81B\x89\xb3\xc8\xda\xebZ\x89\x19\xa6\x88\xa0\xfc\xc7`\xee\x15\xc2\xea\x0b1\xd6\xc4$\xd5.\xec@\xe38Q\xd0r\xee\xa2>*TO\x95\xcd\xb6\x8e\xcb\x0b\x03\x00\x9c\ro\x8aY\xf5"\xefs\x01\xf6\xe2*\x84>GbW\xa5\xd7\xc6\x14a\xdanL\xde>\x06\x1cW\x94\xf3\x06\xc7\xaaCn\xfb\xc9&\xd0\xf1\x9e\x81^\xc7\xb5ql\'\x96ES\x80\xf2,\x96\xa3\x92\xec\xb35\xc6P\xa2$f\x071\xa1\xca\xf4u\x1a\xa8\xc3\x8e\xf7G\xb4\x88+t\x12\x03\xf4\x88N\x07\xc7\xd3\x11\r\xb1\xe2Au\x12\xeb\x87e\xa9\x01\xaa\xf3\x0cQ\x08:\xc5\x9d\x1aH\xcbWt\x18\x7fQ\x1f\x8d_\x11_g\xaf\n\xf7;\xc5\xf7\xbfA|.>Z\x8dZ\r\x9a4\x15T\'\xca\xccJb2F\xf1L3\x93L\x7f_\xaaT:\xd5G|\xc3Wr\xf1\x8e\x9e\x8b9\x14\xac<\x81\x8c\xde\x84\xb7\x96v\xa4\xe1\xa9\xde\xa5\x81@/\xef\x9d\x81`\x02\xed\x90\xf9M\x8c\xff\x1b\x1c\x01\xd9L\xd1\xb2]7\x9e\x08t\x9c\r\xccs\xc9\xfc\xd0b\xe0\xafK\x9a\x17\x03\xeb;\xc8\x14{\x87J\xab\x04\xdcYY\x1d"t\x90\x03\xe1N\xbeo\x05\xd0\x8b\xed\x9a\x93\xf6i\x8b\xc4\xbaM\xaa\tU\x01\x10\xac\xf8\xd6\x90:-signature-:\x0f\xdf\xf8\x9a\xf7g\xe5\x9f73\xb5\xe6\xf0\xb0?\xc9^\x99@\x8f\xbc<\x01\xa5\x1f\x00\xfd\x9c\x8c\xe6`\x8bv\xea\x1e\xb23\x14\x8cm\xe3\x00z\xc0{\n\xf8\x89T\xf2\x08\xbew\x99\xa3%t\xebp\xfbk9\xed\xaa\x0e7\xd3\x92\xf1\xf7\xdf\xadJ\x06\xfd6\x85\xc8{\xb9\x8b>_m7\xc8\xe10\xfet+\xe85\x12\xd8\xbed{/\x8d\xe6\xcc\x92d\x97\x07\xf5\x12O\xc3u\x1a\x10\xd7\x8a"tRz\xb0\x05\x0f\xdf\xbbs\n\xa3\xf8\xc8\x9e\x7f\x00\x85!\xd6l\xebc\xa3=\x7f\x85v\xdfS\xe4"6\xb0!\xa1!\x9a\x83\xe2-1\xe1\xf0\xd60\x9c;;\xa6ZT\xa4l\xf2\x99\r\x962\x8b$b\xd9\x86r)\x17~\x1b\xc3\x03-E\xc6\\[a\x1b\xd1\xd2\xc5\xcbs\x9dx\x08\xcb\x923P\xbe4\x182\xe5\xbc#\xde\xea]Fz\x883\x04\xf5\xab\x0e\xac\x06\x1f#\xa6;\x8ef\xc9h?^=\x15\xd0\x86W\xf6\xcb\x9e\x94}\xe3v\xd6r\xdf\xf0\x1b\xd2\xc4\xec\x83?2)\xc2\xf8\x82\xc1\xce\xec;\x97\xb1\xdcp\x19\x00\xec\xb6\x05\xd9\xc8^\xcd?\x9f?\xfb\x11\n\xc6~\x81\x9f\xb7\xef\x052\x07\x93\xf6*\x0b\xd78\xc0\xd9\xeem\x9d#A\xdd\xeb\xafq\x0e\xba\xde;\xdb\x989\xd9)\xb1\xdcC<\xd0h\x8e\xa3\x8b\xf5\xde\x88\xb30\xd5\xdd\x1b\xae\x07\x11\xb0\xc4\xbb\x0eQ\x83\x94b\xf2^\xac*\xc6\x16\xd6\xe0U\xf4\x10r\xda;\xfd\x0f k\xc5\xc16\xe8v\xa4\x0co$B/\x19\x8f9\xdctV\xbcB\xbbN\xb1\xfd#\xb9\xfb\xdb \xab\xa0\xc2\xf6h\xc3\xeb\xb2\xfe\xd2\xd9\xa9\x8e\x02\x10V\x1aB\xd6\xf7\x84\x81`\xf3~DO~\xf0\xe2f\x8d\x14^i\xc2\xca\x8b\xd3L\x92\x1co\xaba\xf5\xb1\x19f\xd5\xde+\xed\xd0\xc3\x08\xd2,\x17s\x93\x1e\x02\xbf\xc9\x00\x12\x7f\xfc\x93\xe2\x14a\xba\xf5R\x8aRM\x01\xa8\x9a\')x\xed\xe6\xe1\x89\x98\xfe\xa1\x9dW\xa6\x85o\xe5\xee\xc7\x87\xc9\xe9\t#\xd2y\xdc@\x9a\xee\xc4\xb2eW\xce\xf7.' , len = 1110
encrypting message client
encryptedByte = b'\x91E\xf6\xd4\x89\x92\x825:-helper:-\xf9\n,\x81\xfa\xdf\xf4\xcd\x1ers\xd8M\xbe\x84\\:-helper:-\x8b5\x9f\x95\x80\xf0\x1c\xc9\x91\xc6\x14\xedH\\\xec\x14:-encKey-: \xa9|\xd2\xcei\xff)\xda\x83\xef\xe3\x1e\xb53W\x07\xcay\x12\xa0r\x9d,\xef[\xeag\x84\xfb\xcb\x0c\x9b\r\xc8\xbb\x12\xbc\x96\x8d\xa0\xe8\xb6\x9b\x8e\xe7P\x95T\x0b1\x99\rQ\x8a\x1f\xb5U\x0c\x07\xdaQ}K\x9c\xd1\xc4\xee\x93\x91X\xb1\x05\xc1\x1d<(\x8bp\xe2e\x99\x0f\x88,\xd0\\z,F\x02^m V;V\xd3.\x8d\xa3\xfd7\xael\xe6\x08g\x9dJ\xe51*`\xfaSz\xdf^yBu\x0eT\x85}\x03\xda\x16\x08\x1e\x86?\xc3j\n\x12\xaf(\xa2\xd4X*\xc7y\x82\xe9\x01\xae\xc4\x0c\xb4\xfb\xe2C\x08\xc8~\x9c\xf0\xf4+g\xdf\xa66]X\x85d\x17-u\x85\xa3\xc1\xda\x9bLp\xedc\xf5M|\xa8\x9c\xf2G\xd9\xd4o\x8a9\x9c\xd8\xc7\xf9e\xcc\'\xa7\x81\xcf\xce\xc2\xe1Z\x006\xdb\x9f\xe3\x9dq\xad\x90\xe5\x81\x11\x9dh \xdd&\xd2\xf4e\xc8\xae 8D\xeaq\xb4j\xeabY\x1d\xb9\x9fg\x15\xc0O\xb8"\xca\x9e\xd6^\x98\x8dZ\x1f,J\xa0\x13[[L\xad\xb09C\x02\x8d\x15\xe8\x1f;\x83)\xf9\xb0I-~W\x86\x8f\xf5\xcf\xb4~`\xcc\x11p\xb3ZdK\xe0\xb8\xea\xa9\x86Q\xc7\x80c\xb31\xab,\x94G\xc4\x88Y\xbb\xfdd\xc3b\xb8\xaa\x81\xe1\x91dr\x05\xed^\xbc\xafn\xd1\x95\xb5_\x9d\xc6\xa0\xe9\xad\xffbA\xee\x1d5\x9f\xdc6\x16q\xafD\xfcN\x7f\xde\xa9\xa2\x8d%a\xb7H>\xce\xa9\xd1\x15w\x06to;t]\x03%\x90\x18z\xc2M\xb0s\xa9\x9d\xc5Z~\x18tz\xa4\x15N[\x7f\xd6\x92,\x84\x1b\x8d\x1ei\xear\x19\xe3\xdc\xcb/1r\xc5\xc6k o\xaf\xce\xd1\xa2\x0b\x0b\xa4u\xcbFr\xf3\x94\xb4\xe4\x04\x97\xeb\x1d\xea\x94x\x836\x18~\x91\x81\x1dZ\xe5\xd7v\x9e\xc3\x9e\x05KMC\xc2\xcc7@\x96.\xf9n#\xb6?\xe2\x99f\xa9\xdb\xe6\xfa\xf6,\xb3\x14\x0e\x10S\xac\tiU\x98\x8a\xb77\xc0\x9bg\xaf\x1b\xcdv\xc1y\xd8\xe6\x10b\x9f(e=\x8b:-signature-:Z\x10\x87z\t\x0f\xb1u\xd0\x8e<\xafZ\xcd\xd4z\x9e\xd8\xc7\xc2\xb4\xde\xea7\xd6\x00%>b\xee\xec\xdc\xd8(A[;g\xcc\x9b\x17\x0c_\x82\xdb\xff\xe4"\xd3e\x9a\xbco\x80\xce3\xe6=\x1f@M#R\xb3\xce\xb5<\xa3m.\xf4t\xee\x06\xab:\xc9\xb1\x99\x03r\x96\x99B\x18\x85%\x02c\x1c8t\ns|@\x02\xafI\x94\x0e\xd9vv\xe6\x1e\xf5\xe6\x857\xdd\x83\x0e\x0ce[\xfb\x9b\x1e\xd9\xce\xd7\xfaL\x80\xba\xa8->\xb6Wx\xd8\x84f\xe8\xd4\xa4\xc7\xf5\x8c\xadMu\x98H\xa3\xf2\xfd\xaf\x02Ih\x9cC$\xf7$.`\x83-1.\x89\x9e\x91\xa2\x1fn\x02\xfbe\xc5g\xdab\xe0\x14\xcb\xcb\x98\x03\xa5\xd9\x17\xc1\x8c&q0\xb1\xd2y\xb9\x04D\xb4\xc10p|i\x9e\xf0\xa4,\xaa\xdc\x121;|;4\xdbS4\xa5\x1e\x86U h+\xf8\xd2\x90\x9a"?\xe4ifB\xa0\x9ar\xbb\x0f\x18KS\xe1\xd7g\xe9\xf4\xe98w\xc3\xd4\xfc\xf6\x1b\x92\xd8\x0f\xcbO]x,3O\x84O*\'\xe5z~>\xb8\x1f\xb6\xb6p|}\xd3\x1asC\x80\xb8_\xe5>\xea\xbd+\xf7\xed\xa1\x8e\xd0<\xd9\x1ag\x96\\pS\xac\xf6#0g5q \xbf\xb3\xb8\xde\xce\x18\xfd-\xa0 B\x95\x86\x15B5!2t\xc6\xd8\x81\xaa\xe8\xb1Y=e!\xd2\xf9\xc9^\xf95\x95\x89\x0c\xb5\x0e\xe3rH\x1bb]\x06E\xbb\xd5\xe4\x04\x8a\xb7)\x00f\xb1%t\xe5tk\x8b\x89Ok[\xb4\xd1k\xd8\xceG%i\xbd+u\xa3\x92J\xd8E\xa1\xad\xd5\x90M\xa9By\xfc\x99\x9c\xf4!\xfd\xdaC\x0e^8\x12k\x1b\xa7nu\xc8&\xfc\xec\xd1\x7fh\xd5\x07\xfb[\xf6T\xf6\x1ca\x07\xdd%\x11\r\x1b\xe7\xfe\x1f\xf3\xbaY:\xc4\xda\x17\x9c\xce}\xd4\xee\x84\xc7\x1b\'\xfd\x82\xa9\x91C\x8c\x7f\xaa\xfe\xa4\xbc[2E\x1fL\x7f\x91q\xf5\xcb\xa2\x8a\xc87\xa7\x92\x04\x8a\xca\xa8.f\xf8\xd5q\x82j\xf4\x06\xd3in{_\x85\xfb\x05' , len = 1107




client decrypting servers message
decryptedByte_client = b'hello world' , len = 11

ok
server decrypting clients message
decryptedByte_server = b'hi there' , len = 8

ok
```


<br>
<br>
<br>

NOTE -> Both the above method also have a generator version which are important in tracking the progress of encryption and decryption of large data.



<br>
<br>
<br>















### 2.3 generator version - encrypt byte

``` python
encObj.encrypt_byte_yield(byte)
```

* byte -> byte you want to encrypt
* returns encrypted byte

<br>
<br>


### 2.4 generator version - decrypt byte

``` python
encObj.decrypt_byte_yield(enc_byte)
```

* enc_byte -> encrypted byte
* returns decrypted byte

<br>
<br>


Example - 

```python

    print("generating server key")

    keyObj_server = KeyGenerator()

    publicKey_server = keyObj_server.get_publicKey_bytes()
    privateKey_server = keyObj_server.get_privateKey_bytes()


    print("generating client key")

    keyObj_client = KeyGenerator()

    publicKey_client = keyObj_client.get_publicKey_bytes()
    privateKey_client = keyObj_client.get_privateKey_bytes()



    print("encrypting message server")
    encObj_server = Encryptor(publicKey_client , privateKey_server)

    serverMessageSize = 1000 * 1000 * 64
    myByte_server = b"h" * serverMessageSize

    print("serverMessageSize" , len(myByte_server))

    genObj = encObj_server.encrypt_byte_yield(myByte_server)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            encryptedByte_server = ex.value
            break
    print()

    print(f"encryptedByte_server len = {len(encryptedByte_server)}")




    print("encrypting message client")
    encObj_client = Encryptor(publicKey_server , privateKey_client)

    clientMessageSize = 1000 * 1000 * 64
    myByte_client = b"X" * clientMessageSize

    print("clientMessageSize" , len(myByte_client))

    genObj = encObj_client.encrypt_byte_yield(myByte_client)

    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            encryptedByte_client = ex.value
            break
    print()

    print(f"encryptedByte len = {len(encryptedByte_client)}")



    print("\n\n\n")

    print("client decrypting servers message")

    genObj = encObj_client.decrypt_byte_yield(encryptedByte_server)
    
    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            decryptedByte_client = ex.value
            break
    print()

    print(f"decryptedByte_client len = {len(decryptedByte_client)}")

    
    if(decryptedByte_client != myByte_server):
        print("\nerror")
    else:
        print("\nok")



    print("server decrypting clients message")

    genObj = encObj_server.decrypt_byte_yield(encryptedByte_client)
    
    print()
    while(True):
        try:
            currentCount , totalYield = next(genObj)
            # print(currentCount , totalYield)
            printProgressBar(currentCount, totalYield, prefix = 'Progress:', suffix = 'Complete', length = 50)
        except StopIteration as ex:
            decryptedByte_server = ex.value
            break
    print()

    print(f"decryptedByte_server len = {len(decryptedByte_server)}")

    
    if(decryptedByte_server != myByte_client):
        print("\nerror")
    else:
        print("\nok")


```

Output - 

```shell
generating server key
generating client key
encrypting message server
serverMessageSize 64000000

Progress: |██████████████████████████████████████████████████| 100.0% Complete

encryptedByte_server len = 64001309
encrypting message client
clientMessageSize 64000000

Progress: |██████████████████████████████████████████████████| 100.0% Complete

encryptedByte len = 64001309




client decrypting servers message

Progress: |██████████████████████████████████████████████████| 100.0% Complete

decryptedByte_client len = 64000000

ok
server decrypting clients message

Progress: |██████████████████████████████████████████████████| 100.0% Complete

decryptedByte_server len = 64000000

ok
```



<br>
<br>
<br>
<br>
<br>
















# 3. String Encryptor

convert string into bytes by using [encoder decoders](https://www.letscodeofficial.com/documentations/pySecureCryptos%20encoderDecoders#/) then use above bytes encryptor to encrypt. You can convert the encrypted byte back to string using [HexEncoder in encoder decoders](https://www.letscodeofficial.com/documentations/pySecureCryptos%20encoderDecoders#/?id=_3-b2s-hex-convert-byte-to-hexa-decimal-string-and-vice-versa)